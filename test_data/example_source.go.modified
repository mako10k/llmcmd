// Modified version with additional features
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

// User represents a user in the system
type User struct {
	// Additional user tracking fields
	ID       int       `json:"id"`
	Name     string    `json:"name"`
	Email    string    `json:"email"`
	Created  time.Time `json:"created"`
	Active   bool      `json:"active"`
	Role     string    `json:"role"`
	Settings map[string]interface{} `json:"settings"`
}

// UserManager handles user operations
type UserManager struct {
	users    map[int]*User
	nextID   int
	logger   *log.Logger
	maxUsers int
}

// NewUserManager creates a new user manager
func NewUserManager(maxUsers int) *UserManager {
	return &UserManager{
		users:    make(map[int]*User),
		nextID:   1,
		logger:   log.New(os.Stdout, "[UserManager] ", log.LstdFlags),
		maxUsers: maxUsers,
	}
}

// CreateUser creates a new user
func (um *UserManager) CreateUser(name, email, role string) (*User, error) {
	if len(um.users) >= um.maxUsers {
		return nil, fmt.Errorf("maximum users limit reached: %d", um.maxUsers)
	}

	if name == "" {
		return nil, fmt.Errorf("name cannot be empty")
	}

	if email == "" {
		return nil, fmt.Errorf("email cannot be empty")
	}

	// Check if email already exists
	for _, user := range um.users {
		if user.Email == email {
			return nil, fmt.Errorf("email already exists: %s", email)
		}
	}

	user := &User{
		ID:       um.nextID,
		Name:     name,
		Email:    email,
		Created:  time.Now(),
		Active:   true,
		Role:     role,
		Settings: make(map[string]interface{}),
	}

	um.users[um.nextID] = user
	um.nextID++
	um.logger.Printf("Created user: %s (ID: %d)", name, user.ID)

	return user, nil
}

// GetUser retrieves a user by ID
func (um *UserManager) GetUser(id int) (*User, error) {
	user, exists := um.users[id]
	if !exists {
		return nil, fmt.Errorf("user not found: %d", id)
	}
	return user, nil
}

// UpdateUser updates user information
func (um *UserManager) UpdateUser(id int, name, email string) error {
	user, exists := um.users[id]
	if !exists {
		return fmt.Errorf("user not found: %d", id)
	}

	if name != "" {
		user.Name = name
	}

	if email != "" {
		// Check if email already exists (excluding current user)
		for uid, u := range um.users {
			if uid != id && u.Email == email {
				return fmt.Errorf("email already exists: %s", email)
			}
		}
		user.Email = email
	}

	um.logger.Printf("Updated user: %s (ID: %d)", user.Name, id)
	return nil
}

// DeleteUser removes a user
func (um *UserManager) DeleteUser(id int) error {
	_, exists := um.users[id]
	if !exists {
		return fmt.Errorf("user not found: %d", id)
	}

	delete(um.users, id)
	um.logger.Printf("Deleted user ID: %d", id)
	return nil
}

// ListUsers returns all users
func (um *UserManager) ListUsers() []*User {
	users := make([]*User, 0, len(um.users))
	for _, user := range um.users {
		users = append(users, user)
	}
	return users
}

// ActivateUser sets user as active
func (um *UserManager) ActivateUser(id int) error {
	user, exists := um.users[id]
	if !exists {
		return fmt.Errorf("user not found: %d", id)
	}

	user.Active = true
	um.logger.Printf("Activated user ID: %d", id)
	return nil
}

// DeactivateUser sets user as inactive
func (um *UserManager) DeactivateUser(id int) error {
	user, exists := um.users[id]
	if !exists {
		return fmt.Errorf("user not found: %d", id)
	}

	user.Active = false
	um.logger.Printf("Deactivated user ID: %d", id)
	return nil
}

// Interactive CLI for testing
func main() {
	fmt.Println("User Management System")
	fmt.Println("Commands: create, get, update, delete, list, activate, deactivate, quit")

	um := NewUserManager(100)
	scanner := bufio.NewScanner(os.Stdin)

	for {
		fmt.Print("> ")
		if !scanner.Scan() {
			break
		}

		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		parts := strings.Fields(line)
		if len(parts) == 0 {
			continue
		}

		command := strings.ToLower(parts[0])
		switch command {
		case "create":
			if len(parts) < 4 {
				fmt.Println("Usage: create <name> <email> <role>")
				continue
			}
			user, err := um.CreateUser(parts[1], parts[2], parts[3])
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Printf("Created user: %+v\n", user)
			}

		case "get":
			if len(parts) < 2 {
				fmt.Println("Usage: get <id>")
				continue
			}
			id, err := strconv.Atoi(parts[1])
			if err != nil {
				fmt.Printf("Invalid ID: %v\n", err)
				continue
			}
			user, err := um.GetUser(id)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Printf("User: %+v\n", user)
			}

		case "update":
			if len(parts) < 4 {
				fmt.Println("Usage: update <id> <name> <email>")
				continue
			}
			id, err := strconv.Atoi(parts[1])
			if err != nil {
				fmt.Printf("Invalid ID: %v\n", err)
				continue
			}
			err = um.UpdateUser(id, parts[2], parts[3])
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Println("User updated successfully")
			}

		case "delete":
			if len(parts) < 2 {
				fmt.Println("Usage: delete <id>")
				continue
			}
			id, err := strconv.Atoi(parts[1])
			if err != nil {
				fmt.Printf("Invalid ID: %v\n", err)
				continue
			}
			err = um.DeleteUser(id)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Println("User deleted successfully")
			}

		case "list":
			users := um.ListUsers()
			fmt.Printf("Total users: %d\n", len(users))
			for _, user := range users {
				status := "active"
				if !user.Active {
					status = "inactive"
				}
				fmt.Printf("  ID: %d, Name: %s, Email: %s, Role: %s, Status: %s\n",
					user.ID, user.Name, user.Email, user.Role, status)
			}

		case "activate":
			if len(parts) < 2 {
				fmt.Println("Usage: activate <id>")
				continue
			}
			id, err := strconv.Atoi(parts[1])
			if err != nil {
				fmt.Printf("Invalid ID: %v\n", err)
				continue
			}
			err = um.ActivateUser(id)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Println("User activated successfully")
			}

		case "deactivate":
			if len(parts) < 2 {
				fmt.Println("Usage: deactivate <id>")
				continue
			}
			id, err := strconv.Atoi(parts[1])
			if err != nil {
				fmt.Printf("Invalid ID: %v\n", err)
				continue
			}
			err = um.DeactivateUser(id)
			if err != nil {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Println("User deactivated successfully")
			}

		case "quit", "exit":
			fmt.Println("Goodbye!")
			return

		default:
			fmt.Printf("Unknown command: %s\n", command)
			fmt.Println("Available commands: create, get, update, delete, list, activate, deactivate, quit")
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Printf("Error reading input: %v\n", err)
	}
}
